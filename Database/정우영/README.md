## 무결성

1. 데이터의 무결성
    - 데이터의 무결성은 데이터의 정확성, 일관성, 유효성이 유지되는 것,
    - 주로 데이터에 적용되는 연산에 제한을 두어 데이터의 무결성을 유지
2. 개체 무결성(Entity integrity)
    - 테이블의 기본키를 구성하는 어떤 속성도 null 이나 중복값을 가질수 없다. 기본키의 속성 값이 널 값이 아닌 원자값을 갖는 성질
3. 참조 무결성(Referential integrity)
    - 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지되는 것
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cac717be-50c5-459c-a9ab-79da5e88a3cc/Untitled.png)
    
    - 위 와 같은 관계에서 department 테이블 에서 삭제가 일어나면 Student 에서 3번째 레코드는 더 이상 존재하지 않는 데이터를 참조하게 된다.
4. 도메인 무결성 (Domain integrity)
    - 필드의 타입, NULL 값 허용 등에 대한 사항을 정의 하고, 올바른 데이터가 입력되었는지 확인하는 것
    - ex) 주민번호에  문자가 입력되는 경우 도메인 무결성이 깨지는 경우
    - DBMS의 기본값 설정, NOT NULL 옵션 등의 제약 사항으로 도메인 무결성을 보장할 수 있다.

# 1. Key

- - 최소성
=> 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질
-- 유일성
=> 하나의 키값으로 튜플을 유일하게 식별할 수 있는 성질

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23e17e4b-dd1a-4f81-9a40-63619faa8af3/Untitled.png)

## super key (수퍼키)

- 유일성의 특성을 만족하는 속성 또는 속성들의 집합,(최소성X, 유일성O)

## candidate key (후보키)

- 최소성O, 유일성O, 슈퍼키 중에서 최소성을 만족하는 속성 또는 속성들의 집합

## primary key (기본키)

- 최소성O, 유일성O, not null 필수
- 여러 후보키 중에서 하나를 선택하여 선택된 키
- 단순한 후보키를 기본키로 선택(권장), 값이 자주 변경될 수 있는 키 는 기본키로 선택 지양

## Alternate Key ( 대체키)

- 기본키를 제외한 나머지 후보키들

## Foreign Key (외래키)

- 어떤 릴레이션에 소속된 속성 또는 속성 집합이 다른 릴레이션의 기본키가 되는 키 입니다.
- 한 테이블이 다른 테이블의 기본키를 참조해서 테이블 간의 관계를 만드는 것
- 무결성을 유지하기 위해서(**데이터 무결성은 데이터의 정확성, 일관성, 유효성이 유지되는 것을 의미합니다. 여기서 정확성이란 중복이나 누락이 없는 상태를 뜻하고, 일관성은 원인과 결과의 의미가 연속적으로 보장되어 변하지 않는 상태를 뜻합니다.)**

# 2. 조인

---

## 조인

- 관계형 데이터 베이스에서는 중복 데이터를 피하기 위해서 데이트를 쪼개 여러 테이블로 나눠서 저장하는데
- 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법
- 적어도 하나의 칼럼을 서로 공유하고 있어야 하므로 이를 이용하여 데이터 검색에 활용

## INNER JOIN

- 교집합으로 기준 테이블과 join 테이블의 중복된 값을 보여줌
- 교차 조인을 한 결과에 조인 조건문을 충족시키는 레코드를 반환
- 표현법
    - 명시적 표현법
        - SELECT * FROM table1 INNER JOIN table2 ON table1.col = table2.col
    - 암묵적 표현법
        - SELECT * FROM table1, table2 WHERE table1.col=table2.col
        

# OUTER JOIN

- 조건문에 만족하지 않는 행도 표시, 조인을 했을 때 한쪽의 테이블에 데이터가 없어도 조인결과에 포함시킴

## LEFT OUTER JOIN

- 테이블 A의 모든 데이터와 테이블 B와 메칭되는 레코드를 포함한 조인

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e4288a4b-28b1-4bbb-b6da-dcce869db1bd/Untitled.png)

- 표현법
    - SELECT * FROM table1 LEFT OUTER JOIN table2 ON table1.n = table2.n
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c68a7aab-5927-4963-8369-a5580460beec/Untitled.png)
    

## RIGHT OUTER JOIN

- 테이블 B의 모든 데이터와 테이블 A와 메칭되는 레코드를 포함한 조인

## FULL OUTER JOIN

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eed3a4df-a6af-47a1-a90b-6d1ef23ffb85/Untitled.png)

## CROSS JOIN

- 두 테이블의 곱집합 한 결과, 특별한 조건없이 테이블 1,2 의 각 행들을 모두 조합한 결과

 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e5d567bb-251b-4f69-8f23-789077780e4f/Untitled.png)

- 명시적 표현법
    - SELECT * FROM table1 CROSS JOIN table2;
- 암묵적 표현법
    - SELECT * FROM table1, table2;

---

# SQL Injection

---

## SQL Injection 개념

- 보안상의 취약점을 이용하여 임의의 SQL 문을 주입하고 실행되게 하여 DB가 비정상적인 동작을 하도록 조작하는 행위

## 공격 방법

- 1.인증우회
- ex)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/131607e8-0bcb-44dc-8d78-4a0661ec4553/Untitled.png)
    
    - OR 1=1 라는 구문을 참으로 만들고  - - 구문을 넣어줌으로써 뒤의 모든 구문을 주석처리
    - User 테이블에 있는 모든 정보를 조회가능 함으로 가장 먼저 만들어진 계정으로 로그인에 성공 할 수 있음
- 2.데이터 노출
    - 시스템에서 발생하는 에러 메시지를 이용한 공격
        
        오류가 발생하면 에러 메시지를 통해 해당 웹앱의 데이터베이스 구조를 유추할 수 있고, 이를 해킹에 활용가능
        

## 방어 방법

1. input 값을 받을때 특수문자 여부 검사
    - 로그인 전, 검증 로직을 추가하여 미리 설정한 특수문자들이 들어왔을 때 요청을 막아낸다.
2. SQL 서버 오류시 발생되는 에러메시지 감추기
    - 사용자는 View 로만 접근하여 에러를 볼 수 없도록 만듬
3. preparestatement 사용
    - 특수문자를 자동으로 escape 해준다
    - 이를 활용해 서버측에서 필터링 과정을 통해서 공격을 방어 가능
4. 웹 방화벽 사용

# SQL vs NOSQL

---

## SQL

- 구조화 된 쿼리 언어(Structured Query Language)
- 데이터베이스 자체를 나타내는 것이 아니라 특정 유형의 데이터베이스와 상호작용을 하는 쿼리 언어
- 데이터는 정해진 데이터 스키마에 따라 테이블에 저장된다.
    - 스키마를 준수하지 않은 레코드는 추가할수 없다.
    - 테이블에서 새로운 필드를 넣고 싶다면 스키마를 수정하지 않는 한 필드를 추가할 수 없다.
- 데이터는 관계를 통해 여러 테이블에 분산된다.
    - 데이터의 중복을 피하기 위해, 데이터들을 여러 테이블로 나누어 저장한다.
    - 데이터가 항상 하나의 테이블에서만 관리되기 때문에 잘못된 데이터가 테이블 전체에 복제되어 발생하는 문제가 없다.

## NoSQL

- 스키마 없음
- 관계없음
- Key- Value의 쌍으로 나타내는 데이터를 배열 형태로 저장
- 
- NoSQL에서는 테이블을 컬렉션으로, 레코드를 문서로 부른다.
- NOSQL에서는 다른 구조의 데이터를 같은 컬렉션에 저장가능
- NoSQL에서는 join할 필요없이 이미 필요한 모든 것을 갖춘 문서를 만들기 때문에 조인 개념이 없음
- NoSQL은 자주 바뀌지 않은 데이터 일 때 사용하기 유리

## SQL vs NoSQL

### SQL의 장점

- 명확하게 정의 된 스키마, 데이터 무결성 보장
- 관계를 통해 각 데이터를 중복없이 한번만 저장가능

### NoSQL의 장점

- 스키마가 없기 때문에, 유연성이 높다, 데이터를 언제든 조정 가능하고 새로운 필드를 추가할 수 있다.
- 데이터를 애플리케이션에 필요한 형식으로 저장하기 때문에 데이터를 가져오는 속도가 빠르다.

### SQL의 단점

- 상대적으로 덜 유연하며 나중에 수정하는 것이 어렵기 때문에 데이터 스키마를 미리 알고 계획해야한다.
- JOIN문이 많은 경우 매우 복잡한 쿼리가 만들어 질 수 있다.
- 수평 확장이 어렵고, 수직 확장만 가능하다.

### NoSQL의 단점

- 데이터가 여러 컬렉션에 중복되어 있어 데이터가 변경되면 여러 컬렉션과 문서를 수정해야한다.
- 유연성으로 인해 데이터 구조 결정이 늦어질 수 있다.

### SQL이 유리할때

- 앱의 여러 부분에서 관련 데이터가 비교적 자주 변경되는 경우(NoSQL 이라면 항상 여러 컬렉션을 수정해야 한다.)
- 명확한 스키마가 중요하며, 데이터 구조가 극적으로 변경되지 않을때

### NoSQL이 유리할때

- 정확한 데이터 요구사항을 알 수 없거나 관계를 맺고 있는 데이터가 자주 변경 되는 경우
- 읽기 처리를 자주하지만 데이터를 자주 변경하지 않는경우( 한번의 변경으로 수십개의 문서를 수정 할 필요가 없는 경우)
- 데이터를 수평으로 확장해야 하는 경우( 막대한 양의 데이터를 다뤄야 하는 경우, 읽기/ 쓰기 처리량이 큰 경우)

# Anomaly(이상)

---

## 테이블 내의 데이터 중복성에 의해 발생되는 데이터 불일치 현상

## 삽입 이상(Insertion Anomaly)

- 불필요한 데이터를 추가해야지 삽입할 수 있는 상황
- 내가 원하는 값만 테이블에 삽입하려 하지만, 테이블에 필요하지 않은 필드들 때문에 원치 않은 필드의 값도 삽입해야 하는 경우
- 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a2ca439d-cf18-4174-b163-daae91e2ebf3/Untitled.png)

- 1,2,3, 번 필드에 대한 값만 테이블에 삽입하려 하지만 테이블이 4개의 필드로 구성되어 있기 때문에 마지막 필드 값을 무엇으로 해야 할 지 결정하지 못함.

## 갱신이상(Update Anomaly)

- 어떤 값을 업데이트 했을 때 그 속성의 다른 속성값들과 불일치가 발생하는 현상
- 반복된 데이터중 일부만 변경하여 데이터가 불일치함
- 모든 튜플을 찾아서 수정해야 한다.

## 삭제 이상(Deletion Anomaly)

- 튜플 삭제로 인해 꼭 필요한 데이터 까지 함께 삭제되는 문제
- 원하는 값만 삭제를 하고 싶지만, 하나의 튜플이 원하지 않는 속성값도 갖고 있기 때문에 같이 지워지는 문제

# Index(인덱스)

---

---

## 인덱스?

- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상 시키기 위한 자료구조
- 데이터 베이스에서 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 함
- Table 의 column을 색인화 하여 관리

### 과정

- Table을 생성하면 MYD, MYI, MYI 파일이 생성된
- MYD (MYsql Data)
    - 실제 데이터가 있는 파일
- MYI (MYsql Index)
    - index 정보가 들어가 있는 파일
- FRM (FoRMat)
    - 테이블 구조가 저장되어 있는 파일

- 사용자가 Select 쿼리로 Index를 사용하는 Column 을 탐색 시 MYI 파일 의 내용을 검색함

## 장단점

### 장점

- 테이블을 조회하는 속도와 그에 따른 성능을 향상 시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

### Where

- 인덱스를 사용 시 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 조건에 맞는 데이터들을 빠르게 찾아 낼 수 있다.

### OREDR BY

- ORDER BY 시에 메모리에서 정렬이 이루어 지고 메모리보다 큰 작업이 필요하다면 디스크 I/O 도 추가적으로 발생하므로 부하가 많이 걸리는 작업
- 인덱스를 사용하면 ORDER BY 에 의한 정렬 과정을 피할 수 있다.

### 단점

- INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 인덱스 테이블 내에 있는 값을 다시 정렬해야하고 인덱스 테이블, 원본테이블 에서 데이터 수정 작업을 해줘야 하기 때문에 DML에서 취약하다.
- DB의 약 10%에 해당하는 저장공간이 추가로 필요하다 .
- 인덱스를 잘못 사용할 경우 오히려 성능 저하 발생가능

## 인덱스를 사용하면 좋은 경우

1. 규모가 작지 않은 테이블
2. INSERT, UPDATE, DELETE 가 자주 발생하지 않는 컬럼
3. JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
4. 데이터의 중복도가 낮은 컬럼

## 인덱스 관리

- 인덱스가 적용된 컬럼에 DML이 수행된다면 계속 정렬을 해주어야 하고 그에 따른 부하가 발생
- DML 수행 시 추가 연산 필요
- INSERT : 새로운 데이터에 대한 인덱스를 추가
- DELETE:  데이터 삭제라는 개념에서 ‘인덱스를 사용하지 않는다’는 작업 수행
- UPDATE: 기존의 인덱스를 사용하지 않음으로 처리하고, 갱신된 데이터에 대해 인덱스를 추가한다.

---

# 정규화

---

관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스

데이터 베이스 정규화의 목표는 이상이 있는 관계를 재구성 하여 작고 잘 조직된 관계를 생성하는 것

데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위해 불필요한 데이터를 제거하고 데이터 저장을 “논리적으로” 함

## 정규화의 목적

1. 데이터의 중복을 최소화 하기 위해, 불필요한 데이터를 제거
2. 데이터베이스 구조확장 시 재 디자인을 최소화(데이터베이스 구조 확장에 용이)
3. 무결성을 지키고, 이상 현상 방지
4. 테이블 구성을 논리적이고 직관적으로 하기 위해

## 정규화 과정

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/41a90c2f-6a6e-4e88-a715-a019d5cdfd39/Untitled.png)

## 제 1 정규화 (부분적 함수 종속 제거) 1NF

테이블의 컬럼이 원자 값을 갖도록 테이블을 분해하는 것.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/68c47f0e-7474-4fab-b7af-8a96e62dde8a/Untitled.png)

## 제 2 정규화(부분적 함수 종속 제거) 2NF

- 테이블의 모든 컬럼이 완전 함수적 종속을 만족하도록 테이블을 분해
- 기본키의 부분집합이 결정자가 되어선는 안된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5d8edd44-8287-4adf-b733-3a2af27eece0/Untitled.png)

위와 같은 경우 (학생번호+강좌이름)이 기본키 이지만 강의실은 기본키의 부분집합인 강좌이름에 따라서 결정될수 있다.

따라서 아래와 같이 기존 테이블에서 강의실을 분해하여 별도의 테이블로 관리하여 제2 정규형을 만족 시킬 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6751e07-afb4-427b-97b5-d05846077219/Untitled.png)

## 제 3 정규화 (이행적 함수 종속 제거) 3NF

- A → B, B → C 일 때 A → C를 만족하면 안된다.
- 기본키가 아닌 속성은 기본키에만 의존해야 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9ecd41e4-10e2-4654-b21c-7bf36db06505/Untitled.png)

- 위 와 같은 경우 학생번호는 강좌 이름을 결정하고, 강좌 이름은 수강료를 결정한다. 따라서 수강료 테이블을 분해해야한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1c6c49eb-02fc-4b55-a671-25661002d2e2/Untitled.png)

---

# 트랜잭션(Transaction)

## 트랜잭션

- 데이터베이스의 상태를 변경시키위해 수행하는 작업의 단위
- DB에서 데이터를 다룰 때 장애가 일어난 경우 데이터를 복구하는 작업의 단위가 된다.
- DB에서 여러 작업이 동시에 같은 데이터를 다룰 때가 이 작업을 서로 분리하는 단위가 된다.
- 트랜잭션은 전체가 수행되거나 또는 전체가 수행되지 않아야 한다. ALL or Nothing

## 트랜잭션의 성질

- 원자성(Atomicity)
    - 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야한다.
- 일관성(Consistency)
    - 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
    - 데이터 타입과 같은 시스템이 가지고 있는 고정요소는 트랜잭션 전후의 상태가 같아야한다.
- 독립성, 격리성(Isolation)
    - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손할 수 없다.
    - 수행중인 트랜잭션이 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
- 지속성, 영속성(Durablility)
    - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

## COMMIT, ROLLBACK

- Commit
    - 하나의 트랜잭션에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을때, 이 태랜잭션이 한 갱신 연산이 왼료된 것을 트랜잭션 관리자에게 알려주는 연산.
- RollBack
    - 하나의 트랜잭션 처리가 비정상적으로 종료 되었을때, 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 유지하기 위해 이 트랜잭션이 행한 모든 연산을 취소하는 연산

## UNDO, REDO

---

# 트랜잭션 격리 수준

### 트랜잭션의 격리수준이란?

- 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것
- 4가지로 정의 가능
    - READ UNCOMMITTED(커밋 되지 않은 읽기) 레벨 0
    - READ COMMITTED(커밋된 읽기) 레벨1
    - REPEATABLE READ(반복 가능한 읽기) 2
    - SERIALIZABLE(직렬화 가능) 3

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6f6dd479-1ebb-4e4b-bb5c-666d7040bc68/Untitled.png)

### READ UNCOMMITTED

- 각 트랜잭션에서의 변경 내용이 COMMIT 이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보여짐
- 데이터 베이스의 일관성을 유지하는 것이 불가능함
- 트랜잭션에서 처리한 작업이 완료되지 않았음에도 불구하고 다른 트랜잭션이 볼 수 있게 되는 현상을 더티리드(Dirty Read)라 하고, 더티리드가 허용도는 격리수준이READ UNCOMMITTED 이다.
- 따라서 MySQL을 사용한다면 READ UNCOMMITTED 이상의 수준을 권장

### READ COMMITTED

- 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨
- commit이 이루어진 트랜잭션만 조회 가능
- 더티리드 현상은 발생하지 않는다.
- 실제테이블 값을 가져오는 것이 아니라 UNDO영역에 백업된  레코드에서 값을 가져옴
에서 값을 가져온다
- Non-Reapeatable Read 문제 발생
    - 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상

### REPEATABLE READ

- 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함
- 변경되기 전 레코드는 UNDO 공간에 백업해두고 실제 레코드값을 반영

### SERIALIZABLE

- 선행 트랜잭션이 특정 테이블을 읽는 경우 락을 걸어 다른 트랜잭션에서 해당 테이블의 데이터를 CUD작업을 못하도록 막는다.

Phantom Read

- 

한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상

트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상임

---

# 저장 프로시저

---

쿼리를 함수처럼 실행하기 위한 쿼리의 집합

프로시저를 만들어 두면 애플리케이션에서 여러 상황에 따라 해당 쿼리문이 필요할 때 인자 값만 전달하여 쉽게 원하는 결과물을 받아낼 수 있다.

### 프로시저의 장점

1. 최적화& 캐시
    - 프로시저의 최초 실행 시 최적화 상태로 컴파일 되며, 그 이후 프로시저 캐시에 저장
    - 만약 여러번 사용되면 컴파일 작업을 거치지 않고 캐시에서 가져옴
2. 유지 보수
    - 작업이 변경되면 다른 작업은 건드리지 않고 프로시저 내부에서 수정만 하면 된다.
3. 트래픽 감소
    - 클라이언트가 직접 sql문을 작성하지 않고 프로시저명에 매개변수만 담아 전달한다.  서버에 이미 저장되있어 클라이언트와 서버간 네트워크 상 트래픽이 감소한다.
4. 보안
    - 프로시저 내에서 참조 중인 테이블의 접근을 막을 수 있다.

### 프로시저 단점

1. 호환성
    - 구문 규칙이 표준과 호환성이 낮기 때문에 코드 자산으로의 재사용성이 나쁨
2.  성능
    
    문자 또는 숫자 연산이 c나 java 보다 성능이 느림
    
3. 디버깅
    - 에러가 발생했을 때 디버깅이 힘듬
